# DAY-2 : 格式化输入输出

## 1.printf()打印函数

### printf 函数

`printf()`函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时使用 `%d`，打印字符时使用 `%c` 。这些符号被称为**转换说明**（conversion specification）,它们指定了如何把数据（以2进制形式）转换成可显示的形式。

`格式化字符串`包含三种对象，分别为： 
（1）`字符串常量`； 
（2）`格式控制字符串`； 
（3）`转义字符`

这是 printf（）的格式：

```
printf(格式字符串，待打印项1，待打印项2,...);
```

**待打印项**都是要打印的的项。它们可以是**变量，常量**，甚至是在打印之前计算的**表达式**。

### ⚠️一些说明

C语言的编译器不会检测格式字符串中转换说明中的数量与待打印项总个数是否相匹配。

**1.缺少参数**

```
printf("%d %d\n", i); // wrong
```



printf 会正确显示 i 的值，然后显示一个无意义的整数值。

**2.参数过多**

```
printf("%d\n", i, j);// wrong
```

而在这种情况下，printf 函数会显示变量 i 的值，但是不会显示变量 j 的值

### printf格式控制符格式

printf的格式控制字符串组成如下：

```less
%[flags][width][.prec][length]type
```

即：

```less
%[标志][最小宽度][.精度][类型长度]类型。
```

![](./printf.png)

type用于规定输出数据的类型，含义如下：

| 字符 | 对应数据类型  | 含义                                                         | 示例                                                         |
| :--- | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| d/i  | int           | 输出十进制有符号32bits整数，i是老式写法                      | `printf("%i",123);`输出123                                   |
| o    | unsigned int  | 无符号8进制(octal)整数(不输出前缀0)                          | `printf("0%o",123);`输出0173                                 |
| u    | unsigned int  | 无符号10进制整数                                             | `printf("%u",123);`输出123                                   |
| x/X  | unsigned int  | 无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF（不输出前缀0x) | `printf("0x%x 0x%X",123,123);`输出0x7b 0x7B                  |
| f/lf | float(double) | 单精度浮点数用f,双精度浮点数用lf(printf可混用，但scanf不能混用) | `printf("%.9f %.9lf",0.000000123,0.000000123);`输出0.000000123 0.000000123。注意指定精度，否则printf默认精确到小数点后六位 |
| F    | float(double) | 与f格式相同，只不过 infinity 和 nan 输出为大写形式。         | 例如`printf("%f %F %f %F\n",INFINITY,INFINITY,NAN,NAN);`输出结果为`inf INF nan NAN` |
| e/E  | float(double) | 科学计数法，使用指数(Exponent)表示浮点数，此处”e”的大小写代表在输出时“e”的大小写 | `printf("%e %E",0.000000123,0.000000123);`输出1.230000e-07 1.230000E-07 |
| g    | float(double) | 根据数值的长度，选择以最短的方式输出，%f或%e                 | `printf("%g %g",0.000000123,0.123);`输出1.23e-07 0.123       |
| G    | float(double) | 根据数值的长度，选择以最短的方式输出，%f或%E                 | `printf("%G %G",0.000000123,0.123);`输出1.23E-07 0.123       |
| c    | char          | 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符      | `printf("%c\n",65)`输出A                                     |
| s    | char*         | 字符串。输出字符串中的字符直至字符串中的空字符（字符串以空字符’\0‘结尾） | `printf("%s","测试test");`输出：测试test                     |
| S    | wchar_t*      | 宽字符串。输出字符串中的字符直至字符串中的空字符（宽字符串以两个空字符’\0‘结尾） | `setlocale(LC_ALL,"zh_CN.UTF-8");` `wchar_t wtest[]=L"测试Test";` `printf("%S\n",wtest);` 输出：测试test |
| p    | void*         | 以16进制形式输出指针                                         | `printf("%010p","lvlv");`输出：0x004007e6                    |
| n    | int*          | 什么也不输出。%n对应的参数是一个指向signed int的指针，在此之前输出的字符数将存储到指针所指的位置 | `int num=0;` `printf("lvlv%n",&num);` `printf("num:%d",num);` 输出:lvlvnum:4 |
| %    | 字符%         | 输出字符‘%’（百分号）本身                                    | `printf("%%");`输出:%                                        |
| m    | 无            | 打印errno值对应的出错内容                                    | `printf("%m\n");`                                            |
| a/A  | float(double) | 十六进制p计数法输出浮点数，a为小写，A为大写                  | `printf("%a %A",15.15,15.15);`输出：0x1.e4ccccccccccdp+3 0X1.E4CCCCCCCCCCDP+3 |

### 标志（flags）

flags规定输出样式，取值和含义如下：

| 字符  | 名称   |                             说明                             |
| :---: | :----- | :----------------------------------------------------------: |
|   -   | 减号   |      结果左对齐，右边填空格。默认是右对齐，左边填空格。      |
|   +   | 加号   |                     输出符号(正号或负号)                     |
| space | 空格   |             输出值为正时加上空格，为负时加上负号             |
|   #   | 井号   | type是o、x、X时，增加前缀0、0x、0X。 type是a、A、e、E、f、g、G时，一定使用小数点。默认的，如果使用.0控制不输出小数部分，则不输出小数点。 type是g、G时，尾部的0保留。 |
|   0   | 数字零 | 将输出的前面补上0，直到占满指定列宽为止（不可以搭配使用“-”） |

```c
printf("%5d\n",1000);               //默认右对齐,左边补空格
printf("%-5d\n",1000);              //左对齐,右边补空格
 
printf("%+d %+d\n",1000,-1000);     //输出正负号
 
printf("% d % d\n",1000,-1000);     //正号用空格替代，负号输出
 
printf("%x %#x\n",1000,1000);       //输出0x
 
printf("%.0f %#.0f\n",1000.0,1000.0)//当小数点后不输出值时依然输出小数点
 
printf("%g %#g\n",1000.0,1000.0);   //保留小数点后后的0
 
printf("%05d\n",1000);              //前面补0
```

`输出结果：`

```c
 1000
1000
+1000 -1000
 1000 -1000
3e8 0x3e8
1000 1000.
1000 1000.00
01000
```

### 输出最小宽度（width）

用十进制整数来表示输出的最少位数。若实际位数多于指定的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。width的可能取值如下：

| width | 描述                                                         | 示例                                |
| :---- | :----------------------------------------------------------- | :---------------------------------- |
| 数值  | 十进制整数                                                   | `printf("%06d",1000);`输出:001000   |
| *     | 星号。不显示指明输出最小宽度，而是以星号代替，在printf的输出参数列表中给出 | `printf("%0*d",6,1000);`输出:001000 |

### 精度（.precision）

精度格式符以“.”开头，后跟十进制整数。可取值如下：

| .precision | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| .数值      | 十进制整数。 (1)对于整型（d,i,o,u,x,X）,precision表示输出的最小的数字个数，不足补前导零，超过不截断。 (2)对于浮点型（a, A, e, E, f ），precision表示小数点后数值位数，默认为六位，不足补后置0，超过则截断。 (3)对于类型说明符g或G，表示可输出的最大有效数字。 (4)对于字符串（s），precision表示最大可输出字符数，不足正常输出，超过则截断。 precision不显示指定，则默认为0 |
| .*         | 以星号代替数值，类似于width中的*，在输出参数列表中指定精度。 |


示例：

```cobol
printf("%.8d\n",1000);          //不足指定宽度补前导0，效果等同于%06d



printf("%.8f\n",1000.123456789);//超过精度，截断



printf("%.8f\n",1000.123456);   //不足精度，补后置0



printf("%.8g\n",1000.123456);   //最大有效数字为8位



printf("%.8s\n",“abcdefghij”);  //超过指定长度截断
```

输出结果：

```cobol
00001000



1000.12345679



1000.12345600



1000.1235



abcdefgh
```

**注意，**在对浮点数和整数截断时，存在四舍五入。

### 转义字符

转义字符在字符串中会被自动转换为相应操作命令。printf()使用的常见转义字符如下：

| 转义字符 | 意义           |
| :------- | :------------- |
| \a       | 警报（响铃）符 |
| \b       | 回退符         |
| \f       | 换页符         |
| \n       | 换行符         |
| \r       | 回车符         |
| \t       | 横向制表符     |
| \v       | 纵向制表符     |
| \\       | 反斜杠         |
| \”       | 双引号         |

### 类型长度

类型长度指明待输出数据的长度。因为相同类型可以有不同的长度，比如整型有16bits的short int，32bits的int，也有64bits的long int，浮点型有32bits的单精度float和64bits的双精度double。为了指明同一类型的不同长度，于是乎，类型长度（length）应运而生，成为格式控制字符串的一部分。



### 自己的一些小记录

```c
#include <stdio.h>
#include <math.h>
int main(){
    int i,j,k;
    i = 1+2;
    j = 1+2*3;
    k = i + j + -1 + pow(2,3);
    printf("i %d j %d k %d",i,j,k);
    //向大转型 1.0 + 2 ==1.0 + 2.0；
    //在表达式前面加(数据类型)可以强制转化 ，整型
// i = 10;
//float f;
//f = (float)i; // 强制转换int为float类型
    return 0;
}
```

![](./leixinglong.png)

示例代码：

```perl
printf("%hhd\n",'A');               //输出有符号char



printf("%hhu\n",'A'+128);           //输出无符号char



printf("%hd\n",32767);              //输出有符号短整型short int



printf("%hu\n",65535);              //输出无符号短整型unsigned short int



printf("%ld\n",0x7fffffffffffffff); //输出有符号长整型long int



printf("%lu\n",0xffffffffffffffff); //输出有符号长整型unsigned long int
```

输出结果：

```cobol
65



193



32767



65535



9223372036854775807



18446744073709551615
```

**注意：** 
long int到底是32bits还是64bits跟生成的程序是32bits还是64bits一一对应，如果使用g++编译程序的话，可通过`-m32`或`-m64`选项分别生成32bits和64bits的程序。因本人测试代码编译生成的是64bits的程序，所以long int也就是64btis。

## 2.scanf()输入函数

scanf函数的定义：
scanf()是C语言中的一个输入函数。与printf函数一样，都被声明在头文件stdio.h里，因此在使用scanf函数时要加上#include <stdio.h>。（在有一些实现中，printf函数与scanf函数在使用时可以不使用预编译命令）它是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中。

二.scanf函数的相关信息 
1.功能：
        执行格式化输入

 2.调用格式：
        scanf("<格式化字符串>"，<地址表>);

 3.scanf函数字符控制串：
        1.格式化说明符；

        2.空白字符；
    
        3.非白色字符，格式化说明符（%）除外；

4.常见格式化说明符：

 5.scanf函数的返回值：
        首先scanf函数返回的是int型的数据，scanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。

例子：

scanf("%d %d",&a,&b);
如果a和b都读取成功，则返回2。

如果只有a被成功读入，返回值为1；
如果a读取失败，返回值为0；
如果遇到错误或遇到end of file，返回值为EOF。end of file为Ctrl+z 或者Ctrl+d。

三. 使用scanf函数需要注意的问题（重点）
问题一：如何让scanf()函数正确接受有空格的字符串？如: I love you!
#include <stdio.h>

int main()

{

    char str[80];
     
    scanf("%s",str);
     
    printf("%s",str);
     
    return 0;

}
输入：

I love you
输出：

I
上述程序并不能达到预期目的。因为scanf扫描到"I"后面的空格就认为对str的扫描结束（空格没有被扫描），并忽略后面的" love you!"。值得注意的是，我们改动一下上面的程序来验证一下：

#include<stdio.h>

#include<windows.h>

int main(void)

{

    char str[80],str1[80],str2[80];
     
    scanf("%s",str);/*此处输入:I love you!*/
     
    printf("%s\n",str);
     
    Sleep(5000);/*这里等待5秒，告诉你程序运行到什么地方*/
     
    /**
     
    *不是sleep(5)
     
    *1，函数名是Sleep不是sleep。
         *
    2，Windows API中，unsigned Sleep(unsigned)应该是毫秒ms.
     
    */
     
    scanf("%s",str1);/*这两句无需你再输入,是对stdin流再扫描*/
     
    scanf("%s",str2);/*这两句无需你再输入,是对stdin流再扫描*/
     
    printf("%s\n",str1);
     
    printf("%s\n",str2);
     
    return 0;

}
输入：

I love you!
输出：

I 
love 
you!
所以结论是：残留的信息 love you是存在于stdin流中，而不是在键盘缓冲区中。那么scanf()函数能不能完成这个任务？回答是：能！别忘了scanf()函数还有一个 %[] 格式控制符,请看下面的程序：

#include<stdio.h>

int main()
{
    char str[50];
    scanf("%[^\n]",str);/*scanf("%s",string);不能接收空格符*/
    printf("%s\n",str);
    return 0;
}
通过使用scanf("%[^\n]",str)可以有效解决输入字符串中存在空格的问题。

问题二：键盘缓冲区残余信息问题
#include<stdio.h>

int main(void)
{
    int a;
    char c;
    while(c!='N')
    {
    scanf("%d",&a);
    scanf("%c",&c);
    printf("a=%dc=%c\n",a,c);
    /*printf("c=%d\n",c);*/
    }
    return 0;
}
通过对这段代码进行运行后可以发现，scanf("%c",&c)并没有很好地执行给c赋值的操作，对于这个·现象，我们可以启用printf("%d",c)进行排查，运行后可以发现输出的值为10，而10对应的ASCII值正是“\n"，也就是ENTER换行符，因此我们可以这样解释：当输入a的值scanf函数读取完毕后将ENTER直接赋给了c。对于处理这种为问题，我们需要对输入缓冲区进行清理，这样才能够实现正确给C进行赋值。

对此我们就可以使用getchar()函数将换行符清理掉。

getcahr();
或者直接使用fflush(stdin）函数对输入缓冲区进行清理

#include<stdio.h>

int main(void)
{
    int a;
    char c;
    while(c!='N')
    {
        scanf("%d",&a);
        fflush(stdin);
        scanf("%c",&c);
        fflush(stdin);
        printf("a=%dc=%c\n",a,c);    
    }
    return 0;
}
问题三：如何处理scanf()函数误输入造成程序死锁或出错
#include<stdio.h>

int main(void)
{
    int a,b,c;
    scanf("%d,%d",&a,&b);
    c=a+b;/*计算a+b*/
    printf("%d+%d=%d",a,b,c);
    return 0;
}
如上程序，如果正确输入a,b的值，那么没什么问题，但是，你不能保证使用者每一次都能正确输入，一旦输入了错误的类型，就会得到一个错误的结果,呵呵，这可能所有人都遇到过的问题吧？解决方法：scanf()函数执行成功时的返回值是成功读取的变量数,也就是说，你这个scanf()函数有几个变量，如果scanf()函数全部正常读取，它就返回几。但这里还要注意另一个问题，如果输入了非法数据，键盘缓冲区就可能还个有残余信息问题。正确的例程：

#include<stdio.h>

int main(void)
{
    int a,b,c;
    while(scanf("%d%d",&a,&b)!=2)
    fflush(stdin);
    c=a+b;
    printf("%d+%d=%d",a,b,c);
    return 0;
}
四.关于scanf函数的发展：
使用scanf函数进行输入，必须指定输入的数据的类型和格式，不仅繁琐复杂，而且很容易出错。C++保留scanf只是为了和C兼容，以便过去用C语言写的程序可以在C++的环境下运行。C++的编程人员都愿意使用cin进行输入，很少使用scanf。但是scanf有一个明显的优点，速度比cin函数快。

## 3.getchar()字符输入函数

## 4.putchar()函数

